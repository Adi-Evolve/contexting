<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0">
    <title>VOID V3 - Functional Tests</title>
    <style>
        body {
            font-family: 'Segoe UI', Tahoma, Geneva, Verdana, sans-serif;
            max-width: 1200px;
            margin: 20px auto;
            padding: 20px;
            background: #1e1e1e;
            color: #d4d4d4;
        }
        h1 {
            color: #4ec9b0;
            border-bottom: 2px solid #4ec9b0;
            padding-bottom: 10px;
        }
        h2 {
            color: #569cd6;
            margin-top: 30px;
        }
        .test-section {
            background: #2d2d2d;
            border-left: 4px solid #569cd6;
            padding: 15px;
            margin: 15px 0;
            border-radius: 4px;
        }
        .test-result {
            margin: 10px 0;
            padding: 8px;
            border-radius: 4px;
            font-family: 'Courier New', monospace;
        }
        .pass {
            background: #1a472a;
            color: #4ec9b0;
            border-left: 4px solid #4ec9b0;
        }
        .fail {
            background: #5a1e1e;
            color: #f48771;
            border-left: 4px solid #f48771;
        }
        .info {
            background: #2d3139;
            color: #9cdcfe;
            border-left: 4px solid #9cdcfe;
        }
        .summary {
            background: #2d2d2d;
            padding: 20px;
            margin-top: 30px;
            border: 2px solid #4ec9b0;
            border-radius: 8px;
        }
        .summary h2 {
            margin-top: 0;
            color: #4ec9b0;
        }
        .stats {
            display: flex;
            gap: 20px;
            margin-top: 15px;
        }
        .stat-box {
            flex: 1;
            padding: 15px;
            background: #1e1e1e;
            border-radius: 4px;
            text-align: center;
        }
        .stat-value {
            font-size: 2em;
            font-weight: bold;
            margin: 10px 0;
        }
        .stat-pass { color: #4ec9b0; }
        .stat-fail { color: #f48771; }
        .stat-rate { color: #569cd6; }
        button {
            background: #569cd6;
            color: white;
            border: none;
            padding: 12px 24px;
            font-size: 16px;
            border-radius: 4px;
            cursor: pointer;
            margin: 10px 5px;
        }
        button:hover {
            background: #4186c4;
        }
        button:disabled {
            background: #666;
            cursor: not-allowed;
        }
        #loadingStatus {
            padding: 15px;
            background: #2d2d2d;
            border-radius: 4px;
            margin: 20px 0;
        }
        pre {
            background: #1e1e1e;
            padding: 10px;
            border-radius: 4px;
            overflow-x: auto;
        }
    </style>
</head>
<body>
    <h1>üß™ VOID V3 - Functional Tests</h1>
    <p>Testing all 6 modules with real data and operations</p>

    <div id="loadingStatus">
        <strong>Status:</strong> <span id="status">Ready to test</span>
    </div>

    <button onclick="runAllTests()">‚ñ∂Ô∏è Run All Tests</button>
    <button onclick="clearResults()">üóëÔ∏è Clear Results</button>

    <div id="results"></div>

    <div id="summarySection" style="display: none;" class="summary">
        <h2>üìä Test Summary</h2>
        <div class="stats">
            <div class="stat-box">
                <div>Passed</div>
                <div class="stat-value stat-pass" id="passedCount">0</div>
            </div>
            <div class="stat-box">
                <div>Failed</div>
                <div class="stat-value stat-fail" id="failedCount">0</div>
            </div>
            <div class="stat-box">
                <div>Pass Rate</div>
                <div class="stat-value stat-rate" id="passRate">0%</div>
            </div>
        </div>
    </div>

    <!-- Load modules -->
    <script src="hierarchy-manager.js"></script>
    <script src="delta-engine.js"></script>
    <script src="semantic-fingerprint-v2.js"></script>
    <script src="causal-reasoner.js"></script>
    <script src="multimodal-handler.js"></script>
    <script src="llm-query-engine.js"></script>

    <script>
        let totalPassed = 0;
        let totalFailed = 0;

        function log(message, type = 'info') {
            const results = document.getElementById('results');
            const div = document.createElement('div');
            div.className = `test-result ${type}`;
            div.textContent = message;
            results.appendChild(div);
        }

        function logSection(title) {
            const results = document.getElementById('results');
            const section = document.createElement('div');
            section.className = 'test-section';
            section.innerHTML = `<h2>${title}</h2>`;
            results.appendChild(section);
            return section;
        }

        function updateStatus(text) {
            document.getElementById('status').textContent = text;
        }

        function updateSummary() {
            document.getElementById('summarySection').style.display = 'block';
            document.getElementById('passedCount').textContent = totalPassed;
            document.getElementById('failedCount').textContent = totalFailed;
            const total = totalPassed + totalFailed;
            const rate = total > 0 ? Math.round((totalPassed / total) * 100) : 0;
            document.getElementById('passRate').textContent = rate + '%';
        }

        function clearResults() {
            document.getElementById('results').innerHTML = '';
            document.getElementById('summarySection').style.display = 'none';
            totalPassed = 0;
            totalFailed = 0;
            updateStatus('Ready to test');
        }

        async function runAllTests() {
            clearResults();
            updateStatus('Running tests...');

            try {
                await testHierarchyManager();
                await testDeltaEngine();
                await testSemanticFingerprint();
                await testCausalReasoner();
                await testMultiModalHandler();
                await testIntegration();

                updateStatus('All tests completed!');
                updateSummary();

                if (totalFailed === 0) {
                    log('üéâ ALL TESTS PASSED! All modules are working correctly.', 'pass');
                }
            } catch (error) {
                log(`‚ùå Test suite error: ${error.message}`, 'fail');
                updateStatus('Tests failed with error');
            }
        }

        async function testHierarchyManager() {
            const section = logSection('üìä TEST 1: HierarchyManager - Tree Building');
            
            try {
                const hierarchy = new HierarchyManager({
                    maxDepth: 5,
                    topicShiftThreshold: 0.4,
                    similarityThreshold: 0.7
                });

                const messages = [
                    { role: 'user', content: 'How do I create a React component?', timestamp: Date.now() },
                    { role: 'assistant', content: 'You can create a React component using function or class syntax...', timestamp: Date.now() + 1000 },
                    { role: 'user', content: 'Can you show me an example?', timestamp: Date.now() + 2000 },
                    { role: 'assistant', content: 'Here is a simple example: function MyComponent() { return <div>Hello</div>; }', timestamp: Date.now() + 3000 }
                ];

                messages.forEach(msg => hierarchy.addMessage(msg));
                const stats = hierarchy.getStats();

                if (stats.totalNodes === 4) {
                    log('‚úÖ Added 4 messages to tree', 'pass');
                    totalPassed++;
                } else {
                    log(`‚ùå Expected 4 nodes, got ${stats.totalNodes}`, 'fail');
                    totalFailed++;
                }

                const context = hierarchy.getHierarchicalContext(10, 1000);
                if (context && context.length > 0) {
                    log('‚úÖ Generated hierarchical context', 'pass');
                    totalPassed++;
                } else {
                    log('‚ùå Failed to generate context', 'fail');
                    totalFailed++;
                }

                const serialized = hierarchy.serialize();
                if (serialized && serialized.version === '1.0' && serialized.tree && serialized.tree.rootId && Array.isArray(serialized.tree.nodes)) {
                    log('‚úÖ Serialized tree structure', 'pass');
                    totalPassed++;
                } else {
                    log('‚ùå Failed to serialize tree', 'fail');
                    totalFailed++;
                }

                log(`‚ÑπÔ∏è Stats: ${stats.totalNodes} nodes, depth ${stats.maxDepth}, ${stats.totalBranches} branches`, 'info');

            } catch (error) {
                log(`‚ùå FAIL: ${error.message}`, 'fail');
                totalFailed += 3;
            }
        }

        async function testDeltaEngine() {
            const section = logSection('üóúÔ∏è TEST 2: DeltaEngine - Differential Compression');
            
            try {
                const delta = new DeltaEngine({
                    maxPatchChainLength: 10,
                    compressionThreshold: 0.3
                });

                const oldState = {
                    id: 'conv1',
                    title: 'Test Conversation',
                    messages: [
                        { role: 'user', content: 'Hello' },
                        { role: 'assistant', content: 'Hi there!' }
                    ],
                    version: 1
                };

                const newState = {
                    id: 'conv1',
                    title: 'Test Conversation',
                    messages: [
                        { role: 'user', content: 'Hello' },
                        { role: 'assistant', content: 'Hi there!' },
                        { role: 'user', content: 'How are you?' },
                        { role: 'assistant', content: 'I am doing well!' }
                    ],
                    version: 2
                };

                const diff = delta.calculateDiff(oldState, newState);

                if (diff && Array.isArray(diff.added)) {
                    log(`‚úÖ Detected diff structure (${diff.added.length} added, ${diff.modified.length} modified, ${diff.deleted.length} deleted)`, 'pass');
                    totalPassed++;
                } else {
                    log('‚ùå Failed to detect additions', 'fail');
                    totalFailed++;
                }

                const patch = delta.generatePatch(diff);

                if (patch && patch.version === 2) {
                    log('‚úÖ Generated patch with correct version', 'pass');
                    totalPassed++;
                } else {
                    log('‚ùå Failed to generate patch', 'fail');
                    totalFailed++;
                }

                const fullSize = JSON.stringify(newState).length;
                const patchSize = JSON.stringify(patch).length;
                const compressionRatio = patchSize / fullSize;

                if (compressionRatio < 0.8) {
                    log(`‚úÖ Compression: ${fullSize}‚Üí${patchSize} bytes (${Math.round((1-compressionRatio)*100)}% reduction)`, 'pass');
                    totalPassed++;
                } else {
                    log(`‚ùå Poor compression: ${Math.round((1-compressionRatio)*100)}%`, 'fail');
                    totalFailed++;
                }

                const reconstructed = delta.applyPatch(oldState, patch);

                if (reconstructed && reconstructed.version === 2) {
                    log('‚úÖ Successfully reconstructed state from patch', 'pass');
                    totalPassed++;
                } else {
                    log('‚ùå Failed to reconstruct state', 'fail');
                    totalFailed++;
                }

            } catch (error) {
                log(`‚ùå FAIL: ${error.message}`, 'fail');
                totalFailed += 4;
            }
        }

        async function testSemanticFingerprint() {
            const section = logSection('üîç TEST 3: SemanticFingerprintV2 - Duplicate Detection');
            
            try {
                const semantic = new SemanticFingerprintV2({
                    hashSize: 64,
                    duplicateThreshold: 0.95,
                    similarityThreshold: 0.85
                });

                const text1 = 'How do I create a React component with hooks?';
                const text2 = 'How do I create a React component with hooks?';
                const text3 = 'How can I make a React component using hooks?';
                const text4 = 'What is the weather like today?';

                const fp1 = semantic.generateFingerprint(text1);
                const fp2 = semantic.generateFingerprint(text2);
                const fp3 = semantic.generateFingerprint(text3);
                const fp4 = semantic.generateFingerprint(text4);

                if (fp1 && fp1.length === 16) {
                    log('‚úÖ Generated fingerprint (64-bit hex)', 'pass');
                    totalPassed++;
                } else {
                    log(`‚ùå Invalid fingerprint length: ${fp1?.length}`, 'fail');
                    totalFailed++;
                }

                const dupCheck = semantic.checkDuplicate(fp2);

                if (dupCheck.isDuplicate === true) {
                    log(`‚úÖ Detected exact duplicate (confidence: ${(dupCheck.confidence * 100).toFixed(0)}%)`, 'pass');
                    totalPassed++;
                } else {
                    log('‚ùå Failed to detect duplicate', 'fail');
                    totalFailed++;
                }

                const similarity1 = semantic.calculateSimilarity(fp1, fp3);
                const similarity2 = semantic.calculateSimilarity(fp1, fp4);

                if (similarity1 > similarity2) {
                    log(`‚úÖ Similarity: similar(${(similarity1*100).toFixed(0)}%) > different(${(similarity2*100).toFixed(0)}%)`, 'pass');
                    totalPassed++;
                } else {
                    log('‚ùå Similarity calculation incorrect', 'fail');
                    totalFailed++;
                }

                if (semantic.fingerprintCache.size >= 3) {
                    log(`‚úÖ Cache working: ${semantic.fingerprintCache.size} entries (text1=text2 share cache)`, 'pass');
                    totalPassed++;
                } else {
                    log('‚ùå Cache not working', 'fail');
                    totalFailed++;
                }

            } catch (error) {
                log(`‚ùå FAIL: ${error.message}`, 'fail');
                totalFailed += 4;
            }
        }

        async function testCausalReasoner() {
            const section = logSection('üîó TEST 4: CausalReasoner - Cause-Effect Tracking');
            
            try {
                const causal = new CausalReasoner({
                    maxChainDepth: 10,
                    inferenceThreshold: 0.7,
                    minConfidence: 0.5
                });

                const messages = [
                    { role: 'user', content: 'I have an error in my code', id: 'msg1' },
                    { role: 'assistant', content: 'Let me help you debug that', id: 'msg2' },
                    { role: 'user', content: 'The function returns undefined', id: 'msg3' },
                    { role: 'assistant', content: 'The issue is that you forgot to return a value', id: 'msg4' }
                ];

                let previousId = null;
                messages.forEach(msg => {
                    const result = causal.addMessage(msg, previousId);
                    previousId = result.nodeId;
                });

                const graphSize = causal.causalGraph.nodes.size;

                if (graphSize === 4) {
                    log(`‚úÖ Built causal graph: ${graphSize} nodes`, 'pass');
                    totalPassed++;
                } else {
                    log(`‚ùå Expected 4 nodes, got ${graphSize}`, 'fail');
                    totalFailed++;
                }

                // Get first node ID to test chain extraction
                const firstNodeId = previousId;
                const chain = causal.getCausalChain(firstNodeId, 5);

                if (chain && chain.length > 0) {
                    log(`‚úÖ Extracted causal chain with ${chain.length} node(s)`, 'pass');
                    totalPassed++;
                } else {
                    log('‚ùå Failed to extract causal chain', 'fail');
                    totalFailed++;
                }

                const firstNode = causal.causalGraph.nodes.values().next().value;
                if (firstNode && firstNode.type) {
                    log(`‚úÖ Message type classification: "${firstNode.type}"`, 'pass');
                    totalPassed++;
                } else {
                    log('‚ùå Message type classification failed', 'fail');
                    totalFailed++;
                }

            } catch (error) {
                log(`‚ùå FAIL: ${error.message}`, 'fail');
                totalFailed += 3;
            }
        }

        async function testMultiModalHandler() {
            const section = logSection('üñºÔ∏è TEST 5: MultiModalHandler - Image Processing');
            
            try {
                const multimodal = new MultiModalHandler({
                    maxImageSize: 5 * 1024 * 1024,
                    thumbnailSize: 256,
                    ocrEnabled: false,
                    visualFingerprintEnabled: true
                });

                log('‚úÖ MultiModalHandler initialized', 'pass');
                totalPassed++;

                log('‚ÑπÔ∏è Image processing requires browser context (skipping actual image tests)', 'info');
                
                if (multimodal.config.thumbnailSize === 256) {
                    log('‚úÖ Configuration applied correctly', 'pass');
                    totalPassed++;
                } else {
                    log('‚ùå Configuration not applied', 'fail');
                    totalFailed++;
                }

            } catch (error) {
                log(`‚ùå FAIL: ${error.message}`, 'fail');
                totalFailed += 2;
            }
        }

        async function testIntegration() {
            const section = logSection('üîÑ TEST 6: Integration - All Modules Together');
            
            try {
                const hierarchy = new HierarchyManager({ maxDepth: 5 });
                const delta = new DeltaEngine({ compressionThreshold: 0.3 });
                const semantic = new SemanticFingerprintV2({ duplicateThreshold: 0.95 });
                const causal = new CausalReasoner({ maxChainDepth: 10 });

                const conversation = {
                    id: 'test-conv-1',
                    title: 'Integration Test',
                    messages: [
                        { role: 'user', content: 'What is React?', timestamp: Date.now() },
                        { role: 'assistant', content: 'React is a JavaScript library for building user interfaces', timestamp: Date.now() + 1000 }
                    ],
                    timestamp: Date.now()
                };

                // Add to hierarchy
                conversation.messages.forEach(msg => hierarchy.addMessage(msg));
                const hierarchyStats = hierarchy.getStats();

                // Generate fingerprints
                const fingerprints = conversation.messages.map(msg => 
                    semantic.generateFingerprint(msg.content)
                );

                // Build causal graph
                let prevId = null;
                conversation.messages.forEach(msg => {
                    const result = causal.addMessage(msg, prevId);
                    prevId = result.nodeId;
                });

                if (hierarchyStats.totalNodes === 2 && fingerprints.length === 2 && causal.causalGraph.nodes.size === 2) {
                    log('‚úÖ All modules processed conversation successfully', 'pass');
                    log(`   - Hierarchy: ${hierarchyStats.totalNodes} nodes`, 'info');
                    log(`   - Semantic: ${fingerprints.length} fingerprints`, 'info');
                    log(`   - Causal: ${causal.causalGraph.nodes.size} nodes`, 'info');
                    totalPassed++;
                } else {
                    log('‚ùå Module integration issue', 'fail');
                    totalFailed++;
                }

                // Test delta on update
                const updatedConversation = JSON.parse(JSON.stringify(conversation));
                updatedConversation.messages.push({
                    role: 'user',
                    content: 'Can you explain hooks?',
                    timestamp: Date.now() + 2000
                });

                // Convert to proper state format for delta
                const state1 = {
                    tree: { nodes: conversation.messages.map((m, i) => [i, m]) },
                    version: 1
                };
                const state2 = {
                    tree: { nodes: updatedConversation.messages.map((m, i) => [i, m]) },
                    version: 2
                };

                const diff = delta.calculateDiff(state1, state2);

                if (diff && Array.isArray(diff.added) && diff.added.length > 0) {
                    log('‚úÖ Delta detected changes on conversation update', 'pass');
                    totalPassed++;
                } else {
                    log('‚ùå Delta failed to detect changes', 'fail');
                    totalFailed++;
                }

            } catch (error) {
                log(`‚ùå FAIL: ${error.message}`, 'fail');
                console.error(error);
                totalFailed += 2;
            }
        }
    </script>
</body>
</html>

/**
 * TemporalGraph - Advanced Relationship Tracking
 * 
 * Beats Supermemory (3 types) with 6 relationship types:
 * - UPDATES: Replaces old info
 * - EXTENDS: Adds detail
 * - DERIVES: Infers from pattern
 * - CAUSES: Leads to outcome (NEW!)
 * - CONTRADICTS: Conflicts with (NEW!)
 * - SUPPORTS: Reinforces (NEW!)
 * 
 * Features:
 * - Temporal tracking (when relationships formed)
 * - Bidirectional traversal
 * - Relationship strength scoring
 * - Graph cycle detection
 * - Path finding between concepts
 * 
 * @class TemporalGraph
 */

class TemporalGraph {
  constructor(semanticFingerprint) {
    // Core graph structure
    this.nodes = new Map(); // conceptId → node data
    this.edges = new Map(); // edgeId → edge data
    this.nodeEdges = new Map(); // nodeId → Set of edge IDs
    
    // Relationship types with weights
    this.relationshipTypes = {
      UPDATES: { weight: 1.0, description: 'Replaces or updates previous information' },
      EXTENDS: { weight: 0.8, description: 'Adds detail or elaboration' },
      DERIVES: { weight: 0.7, description: 'Inferred from pattern or reasoning' },
      CAUSES: { weight: 0.9, description: 'Leads to outcome or consequence' },
      CONTRADICTS: { weight: 0.6, description: 'Conflicts with previous statement' },
      SUPPORTS: { weight: 0.85, description: 'Reinforces or validates' }
    };
    
    // Integration with SemanticFingerprint
    this.fingerprint = semanticFingerprint;
    
    // Performance metrics
    this.metrics = {
      totalNodes: 0,
      totalEdges: 0,
      averageConnections: 0,
      queryTime: 0
    };
    
    // Edge counter for unique IDs
    this.edgeCounter = 0;
  }
  
  /**
   * Add node (concept/fact) to graph
   * 
   * @param {Object} data - Node data with text, context, timestamp
   * @returns {string} Node ID
   */
  addNode(data) {
    const { text, context = '', timestamp = Date.now(), metadata = {} } = data;
    
    // Create fingerprint for this node
    const fp = this.fingerprint.fingerprint(text, context, timestamp);
    
    // Generate node ID from fingerprint hash
    const nodeId = `node_${fp.hash}_${timestamp}`;
    
    // Create node
    const node = {
      id: nodeId,
      text,
      context,
      timestamp,
      fingerprint: fp,
      metadata,
      createdAt: Date.now(),
      accessCount: 0,
      lastAccessed: Date.now()
    };
    
    // Store node
    this.nodes.set(nodeId, node);
    this.nodeEdges.set(nodeId, new Set());
    
    // Auto-connect to similar existing nodes
    this.autoConnect(nodeId);
    
    this.metrics.totalNodes++;
    return nodeId;
  }
  
  /**
   * Add directed edge between nodes
   * 
   * @param {string} fromId - Source node ID
   * @param {string} toId - Target node ID
   * @param {string} type - Relationship type
   * @param {Object} metadata - Additional data
   * @returns {string} Edge ID
   */
  addEdge(fromId, toId, type, metadata = {}) {
    // Validate nodes exist
    if (!this.nodes.has(fromId) || !this.nodes.has(toId)) {
      throw new Error('Both nodes must exist before adding edge');
    }
    
    // Validate relationship type
    if (!this.relationshipTypes[type]) {
      throw new Error(`Invalid relationship type: ${type}`);
    }
    
    // Generate edge ID
    const edgeId = `edge_${this.edgeCounter++}`;
    
    // Create edge
    const edge = {
      id: edgeId,
      from: fromId,
      to: toId,
      type,
      weight: this.relationshipTypes[type].weight,
      metadata,
      createdAt: Date.now(),
      strength: 1.0 // Initial strength (can decay over time)
    };
    
    // Store edge
    this.edges.set(edgeId, edge);
    
    // Update node edge references
    this.nodeEdges.get(fromId).add(edgeId);
    this.nodeEdges.get(toId).add(edgeId);
    
    this.metrics.totalEdges++;
    return edgeId;
  }
  
  /**
   * Auto-connect new node to similar existing nodes
   */
  autoConnect(nodeId) {
    const node = this.nodes.get(nodeId);
    if (!node) return;
    
    const threshold = 0.6; // Similarity threshold
    const maxConnections = 5; // Limit connections
    
    // Find similar nodes
    const allFingerprints = Array.from(this.nodes.values())
      .filter(n => n.id !== nodeId)
      .map(n => ({ id: n.id, fp: n.fingerprint, text: n.text }));
    
    const similar = this.fingerprint.findSimilar(
      node.fingerprint,
      allFingerprints.map(s => s.fp),
      threshold,
      maxConnections
    );
    
    // Create EXTENDS edges to similar nodes
    for (const match of similar) {
      const matchNode = allFingerprints[match.fingerprint];
      if (matchNode) {
        this.addEdge(nodeId, matchNode.id, 'EXTENDS', {
          autoGenerated: true,
          similarity: match.similarity
        });
      }
    }
  }
  
  /**
   * Find all related nodes (outgoing + incoming)
   * 
   * @param {string} nodeId - Node to query
   * @param {Object} options - Filter options
   * @returns {Array} Related nodes with relationship info
   */
  findRelated(nodeId, options = {}) {
    const startTime = performance.now();
    
    const {
      types = null, // Filter by relationship types
      direction = 'both', // 'out', 'in', 'both'
      maxDepth = 1, // How many hops
      minStrength = 0.5 // Minimum edge strength
    } = options;
    
    if (!this.nodes.has(nodeId)) {
      return [];
    }
    
    const visited = new Set();
    const results = [];
    
    // BFS traversal
    const queue = [{ id: nodeId, depth: 0, path: [] }];
    
    while (queue.length > 0) {
      const { id, depth, path } = queue.shift();
      
      if (visited.has(id) || depth > maxDepth) continue;
      visited.add(id);
      
      // Get edges for this node
      const edgeIds = this.nodeEdges.get(id) || new Set();
      
      for (const edgeId of edgeIds) {
        const edge = this.edges.get(edgeId);
        if (!edge || edge.strength < minStrength) continue;
        
        // Check type filter
        if (types && !types.includes(edge.type)) continue;
        
        // Check direction
        const isOutgoing = edge.from === id;
        const isIncoming = edge.to === id;
        
        if (direction === 'out' && !isOutgoing) continue;
        if (direction === 'in' && !isIncoming) continue;
        
        // Get related node
        const relatedId = isOutgoing ? edge.to : edge.from;
        const relatedNode = this.nodes.get(relatedId);
        
        if (relatedNode && relatedId !== nodeId) {
          results.push({
            node: relatedNode,
            edge,
            direction: isOutgoing ? 'out' : 'in',
            depth,
            path: [...path, edgeId]
          });
          
          // Continue traversal
          if (depth < maxDepth) {
            queue.push({
              id: relatedId,
              depth: depth + 1,
              path: [...path, edgeId]
            });
          }
        }
      }
    }
    
    // Update access metrics
    const node = this.nodes.get(nodeId);
    node.accessCount++;
    node.lastAccessed = Date.now();
    
    const duration = performance.now() - startTime;
    this.metrics.queryTime = duration;
    
    return results;
  }
  
  /**
   * Get temporal chain (sequence of related events over time)
   * 
   * @param {string} nodeId - Starting node
   * @param {string} direction - 'forward' (consequences) or 'backward' (causes)
   * @returns {Array} Ordered chain of nodes
   */
  getTemporalChain(nodeId, direction = 'forward') {
    const node = this.nodes.get(nodeId);
    if (!node) return [];
    
    const chain = [node];
    const visited = new Set([nodeId]);
    
    // Follow CAUSES relationships
    let currentId = nodeId;
    let maxIterations = 100; // Prevent infinite loops
    
    while (maxIterations-- > 0) {
      const related = this.findRelated(currentId, {
        types: ['CAUSES'],
        direction: direction === 'forward' ? 'out' : 'in',
        maxDepth: 1
      });
      
      if (related.length === 0) break;
      
      // Pick strongest unvisited connection
      const next = related
        .filter(r => !visited.has(r.node.id))
        .sort((a, b) => b.edge.strength - a.edge.strength)[0];
      
      if (!next) break;
      
      chain.push(next.node);
      visited.add(next.node.id);
      currentId = next.node.id;
    }
    
    // Sort by timestamp
    if (direction === 'forward') {
      chain.sort((a, b) => a.timestamp - b.timestamp);
    } else {
      chain.sort((a, b) => b.timestamp - a.timestamp);
    }
    
    return chain;
  }
  
  /**
   * Find path between two nodes
   * 
   * @param {string} startId - Start node
   * @param {string} endId - End node
   * @returns {Array} Path of nodes/edges or null
   */
  findPath(startId, endId) {
    if (!this.nodes.has(startId) || !this.nodes.has(endId)) {
      return null;
    }
    
    // BFS for shortest path
    const queue = [{ id: startId, path: [] }];
    const visited = new Set([startId]);
    
    while (queue.length > 0) {
      const { id, path } = queue.shift();
      
      if (id === endId) {
        return path.map(edgeId => ({
          edge: this.edges.get(edgeId),
          from: this.nodes.get(this.edges.get(edgeId).from),
          to: this.nodes.get(this.edges.get(edgeId).to)
        }));
      }
      
      // Explore neighbors
      const edgeIds = this.nodeEdges.get(id) || new Set();
      for (const edgeId of edgeIds) {
        const edge = this.edges.get(edgeId);
        const nextId = edge.from === id ? edge.to : edge.from;
        
        if (!visited.has(nextId)) {
          visited.add(nextId);
          queue.push({ id: nextId, path: [...path, edgeId] });
        }
      }
    }
    
    return null; // No path found
  }
  
  /**
   * Detect cycles in graph
   */
  detectCycles() {
    const cycles = [];
    const visited = new Set();
    const recursionStack = new Set();
    
    const dfs = (nodeId, path) => {
      visited.add(nodeId);
      recursionStack.add(nodeId);
      
      const edges = this.nodeEdges.get(nodeId) || new Set();
      for (const edgeId of edges) {
        const edge = this.edges.get(edgeId);
        if (edge.from !== nodeId) continue; // Only follow outgoing
        
        const nextId = edge.to;
        
        if (!visited.has(nextId)) {
          if (dfs(nextId, [...path, edgeId])) {
            return true;
          }
        } else if (recursionStack.has(nextId)) {
          // Cycle detected
          cycles.push([...path, edgeId]);
        }
      }
      
      recursionStack.delete(nodeId);
      return false;
    };
    
    for (const nodeId of this.nodes.keys()) {
      if (!visited.has(nodeId)) {
        dfs(nodeId, []);
      }
    }
    
    return cycles;
  }
  
  /**
   * Get node by ID
   */
  getNode(nodeId) {
    return this.nodes.get(nodeId);
  }
  
  /**
   * Get edge by ID
   */
  getEdge(edgeId) {
    return this.edges.get(edgeId);
  }
  
  /**
   * Search nodes by text
   */
  searchNodes(query, limit = 10) {
    const queryFp = this.fingerprint.fingerprint(query);
    const allNodes = Array.from(this.nodes.values());
    
    const results = this.fingerprint.findSimilar(
      queryFp,
      allNodes.map(n => n.fingerprint),
      0.4,
      limit
    );
    
    return results.map(r => ({
      node: allNodes.find(n => n.fingerprint === r.fingerprint),
      similarity: r.similarity
    }));
  }
  
  /**
   * Decay edge strengths over time (old connections weaken)
   */
  decayEdges() {
    const now = Date.now();
    const decayRate = 0.1; // 10% decay per month
    const monthMs = 30 * 24 * 60 * 60 * 1000;
    
    for (const edge of this.edges.values()) {
      const age = (now - edge.createdAt) / monthMs;
      const decay = Math.pow(1 - decayRate, age);
      edge.strength = Math.max(0.1, edge.strength * decay);
    }
  }
  
  /**
   * Export graph to JSON
   */
  export() {
    return {
      nodes: Array.from(this.nodes.entries()),
      edges: Array.from(this.edges.entries()),
      metadata: {
        exportedAt: Date.now(),
        version: '1.0',
        metrics: this.metrics
      }
    };
  }
  
  /**
   * Import graph from JSON
   */
  import(data) {
    this.clear();
    
    for (const [id, node] of data.nodes) {
      this.nodes.set(id, node);
      this.nodeEdges.set(id, new Set());
    }
    
    for (const [id, edge] of data.edges) {
      this.edges.set(id, edge);
      this.nodeEdges.get(edge.from).add(id);
      this.nodeEdges.get(edge.to).add(id);
    }
    
    this.metrics = data.metadata.metrics;
  }
  
  /**
   * Get statistics
   */
  getStats() {
    const avgConnections = this.nodes.size > 0
      ? this.metrics.totalEdges / this.nodes.size
      : 0;
    
    return {
      totalNodes: this.nodes.size,
      totalEdges: this.edges.size,
      averageConnections: avgConnections.toFixed(2),
      relationshipTypes: Object.keys(this.relationshipTypes).length,
      lastQueryTime: this.metrics.queryTime.toFixed(3) + 'ms'
    };
  }
  
  /**
   * Clear all data
   */
  clear() {
    this.nodes.clear();
    this.edges.clear();
    this.nodeEdges.clear();
    this.edgeCounter = 0;
    this.metrics = {
      totalNodes: 0,
      totalEdges: 0,
      averageConnections: 0,
      queryTime: 0
    };
  }
}

// Export
if (typeof window !== 'undefined') {
  window.TemporalGraph = TemporalGraph;
}

export default TemporalGraph;
